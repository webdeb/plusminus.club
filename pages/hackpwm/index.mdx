# HackPWM

## General Information

HackPWM is a multipurpose dev board based on the RP2040 microcontroller.
As a bare-metal hardware device, it includes the RP2040, an ALPS Encoder, 5 Push Buttons, and an OLED 64x128 Display.
For PWM purposes, it also has a dedicated Output Buffer chip to provide a stable output voltage of 5V and secure the microcontroller GPIO pins from backpropagation voltage from switching power parts (like from inductive loads, etc). It also provides 7 GPIO pins for free use in custom user programs; 2 of those pins can be used as ADC, and I2C and UART are also possible.

![HackPWM Illustration](./photo-with-pins.jpg)

The included software stack allows writing simple and yet powerful programs very quickly. The underlying framework allows the developer to access all pins, input events, and display in an advanced (max freedom) and a simple, convenient way. For example, by using predefined program structures.

Some of the key features to mention here:

- Configuration Storage
- Events accessing
- Render routines
- A reactive view = f(data) paradigm, which allows writing very stable and reliable software.

As all the code is open source, devs are welcomed to provide their classes and sets of behavior flows for the community.
https://github.com/webdeb/nanoshim/tree/hackpwm

### PWM Specs

- 32-bit PWM counter length for each low and high period.
- 7.35 ns â€“ 10 ns step size depending on the CPU clock speed

These are the basic specs of PWM possibilities; however, HackPWM is a flexible device, and with the provided software, it can create fairly complex signal logic for special-purpose systems.
One of the programs and the underlying logic is illustrated below:

### Example PWM System

The 4P System (Push-Pull Pulse-Package) is a set of 4 PWM Channels to fulfill the following needs:
Safe switching of 2 Push-Pull power commutators, phase-shift-package channel, and an HF Pulse channel which gets enabled by the phase-package channel.

![Example PWM System 4P](./example-4p-system.png)

_Ch1 and Ch2 represent the Push-Pull channels. Ch3 is an inverted channel that depends on one of the push-pull channels as inputs to run (can be configured). Ch4 depends on Ch3 as an input.
It's worth mentioning that an input could also be an external signal provided on one of the available GPIO pins; the hardware provides._

The purpose of this program is to demonstrate the flexibility of the underlying stack in creating complex signal cascading.
Go to the documentation page and read more about it.
